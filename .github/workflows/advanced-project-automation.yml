name: Advanced Project Automation

on:
  issues:
    types: [opened, labeled, unlabeled, assigned, closed, reopened]
  pull_request:
    types: [opened, labeled, unlabeled, assigned, closed, reopened, ready_for_review, converted_to_draft]
  issue_comment:
    types: [created]
  pull_request_review:
    types: [submitted]

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  advanced-triage:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const issue = context.payload.issue || context.payload.pull_request;
            const comment = context.payload.comment;
            const review = context.payload.review;
            
            if (!issue) return;
            
            const issueNumber = issue.number;
            const issueTitleLower = issue.title.toLowerCase();
            const issueBodyLower = (issue.body || '').toLowerCase();
            
            // Handle comment-based automation
            if (comment) {
              const commentBody = comment.body.toLowerCase();
              
              // Check for blocking issues
              if (commentBody.includes('blocked by #') || commentBody.includes('depends on #')) {
                await github.rest.issues.addLabels({
                  owner,
                  repo,
                  issue_number: issueNumber,
                  labels: ['blocked']
                });
                console.log('Added blocked label due to dependency comment');
              }
              
              // Check for ready for review
              if (commentBody.includes('ready for review') || commentBody.includes('please review')) {
                await github.rest.issues.addLabels({
                  owner,
                  repo,
                  issue_number: issueNumber,
                  labels: ['review-requested']
                });
                console.log('Added review-requested label');
              }
              
              // Check for work in progress
              if (commentBody.includes('wip') || commentBody.includes('work in progress')) {
                await github.rest.issues.addLabels({
                  owner,
                  repo,
                  issue_number: issueNumber,
                  labels: ['in-progress']
                });
                console.log('Added in-progress label');
              }
            }
            
            // Handle PR review automation
            if (review && context.payload.pull_request) {
              if (review.state === 'approved') {
                // Remove review-requested, add approved
                try {
                  await github.rest.issues.removeLabel({
                    owner,
                    repo,
                    issue_number: issueNumber,
                    name: 'review-requested'
                  });
                } catch (e) { /* Label might not exist */ }
                
                await github.rest.issues.addLabels({
                  owner,
                  repo,
                  issue_number: issueNumber,
                  labels: ['approved']
                });
              } else if (review.state === 'changes_requested') {
                await github.rest.issues.addLabels({
                  owner,
                  repo,
                  issue_number: issueNumber,
                  labels: ['changes-requested']
                });
              }
            }
            
            // Handle issue/PR state changes
            if (context.payload.action === 'opened') {
              // Auto-detect type based on title patterns
              const labels = [];
              
              // Bug detection
              if (issueTitleLower.includes('bug') || issueTitleLower.includes('fix') || 
                  issueTitleLower.includes('error') || issueTitleLower.includes('issue')) {
                labels.push('bug');
              }
              
              // Enhancement detection  
              if (issueTitleLower.includes('feature') || issueTitleLower.includes('enhancement') ||
                  issueTitleLower.includes('add') || issueTitleLower.includes('implement')) {
                labels.push('enhancement');
              }
              
              // Documentation detection
              if (issueTitleLower.includes('doc') || issueTitleLower.includes('readme') ||
                  issueTitleLower.includes('documentation')) {
                labels.push('documentation');
              }
              
              // Testing detection
              if (issueTitleLower.includes('test') || issueTitleLower.includes('testing')) {
                labels.push('testing');
              }
              
              // Performance detection
              if (issueTitleLower.includes('performance') || issueTitleLower.includes('optimization') ||
                  issueTitleLower.includes('speed') || issueTitleLower.includes('slow')) {
                labels.push('performance');
              }
              
              // Security detection
              if (issueTitleLower.includes('security') || issueTitleLower.includes('vulnerability') ||
                  issueTitleLower.includes('auth') || issueTitleLower.includes('permission')) {
                labels.push('security');
              }
              
              if (labels.length > 0) {
                await github.rest.issues.addLabels({
                  owner,
                  repo,
                  issue_number: issueNumber,
                  labels: labels
                });
                console.log(`Auto-detected type labels: ${labels.join(', ')}`);
              }
              
              // Add to backlog by default
              if (!context.payload.pull_request) {
                await github.rest.issues.addLabels({
                  owner,
                  repo,
                  issue_number: issueNumber,
                  labels: ['status:backlog']
                });
              }
            }
            
            // Handle status transitions for PR events
            if (context.payload.pull_request) {
              if (context.payload.action === 'ready_for_review') {
                // Remove draft status, add review status
                const labelsToRemove = ['status:draft', 'in-progress'];
                for (const labelName of labelsToRemove) {
                  try {
                    await github.rest.issues.removeLabel({
                      owner,
                      repo,
                      issue_number: issueNumber,
                      name: labelName
                    });
                  } catch (e) { /* Label might not exist */ }
                }
                
                await github.rest.issues.addLabels({
                  owner,
                  repo,
                  issue_number: issueNumber,
                  labels: ['status:review']
                });
              } else if (context.payload.action === 'converted_to_draft') {
                await github.rest.issues.addLabels({
                  owner,
                  repo,
                  issue_number: issueNumber,
                  labels: ['status:draft', 'in-progress']
                });
              }
            }
            
            // Handle closing automation
            if (context.payload.action === 'closed') {
              // Remove all status labels and add done
              const statusLabels = ['status:backlog', 'status:in-progress', 'status:review', 'status:draft'];
              for (const labelName of statusLabels) {
                try {
                  await github.rest.issues.removeLabel({
                    owner,
                    repo,
                    issue_number: issueNumber,
                    name: labelName
                  });
                } catch (e) { /* Label might not exist */ }
              }
              
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number: issueNumber,
                labels: ['status:done']
              });
            }

  file-based-component-detection:
    runs-on: ubuntu-latest
    if: github.event.pull_request && github.event.action == 'opened'
    steps:
      - uses: actions/checkout@v4
      - uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const pullNumber = context.payload.pull_request.number;
            
            // Get files changed in the PR
            const files = await github.rest.pulls.listFiles({
              owner,
              repo,
              pull_number: pullNumber
            });
            
            const changedFiles = files.data.map(file => file.filename);
            const labels = [];
            
            // Component detection based on file paths
            if (changedFiles.some(file => file.startsWith('app/') || file.startsWith('routing/') || 
                                          file.includes('main.py') || file.includes('wsgi.py'))) {
              labels.push('component:backend');
            }
            
            if (changedFiles.some(file => file.startsWith('frontend/') || file.startsWith('static/') ||
                                          file.includes('.html') || file.includes('.css') || file.includes('.js'))) {
              labels.push('component:frontend');
            }
            
            if (changedFiles.some(file => file.startsWith('mobile/'))) {
              labels.push('component:mobile');
            }
            
            if (changedFiles.some(file => file.includes('test') || file.startsWith('tests/'))) {
              labels.push('component:testing');
            }
            
            if (changedFiles.some(file => file.includes('docker') || file.startsWith('.github/') ||
                                          file.startsWith('k8s/') || file.startsWith('nginx/'))) {
              labels.push('component:infrastructure');
            }
            
            if (changedFiles.some(file => file.includes('genetic') || file.includes('simulated') ||
                                          file.includes('ml_') || file.includes('optimization'))) {
              labels.push('component:ml');
            }
            
            if (changedFiles.some(file => file.includes('README') || file.includes('.md') ||
                                          file.includes('docs/'))) {
              labels.push('documentation');
            }
            
            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number: pullNumber,
                labels: labels
              });
              console.log(`Added file-based labels: ${labels.join(', ')}`);
            }
