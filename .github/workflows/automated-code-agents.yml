name: ðŸŽ¯ Automated Code Agents

on:
  schedule:
    # Run code maintenance agents daily at 3 AM
    - cron: '0 3 * * *'
  workflow_dispatch:
    inputs:
      agent_type:
        description: 'Type of code agent to run'
        required: true
        default: 'maintenance'
        type: choice
        options:
          - maintenance
          - security_audit
          - performance_optimization
          - dependency_update
          - code_cleanup
      target_directory:
        description: 'Target directory to analyze'
        required: false
        default: 'app/'
        type: string

concurrency:
  group: auto-agents-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions: {}
# Top-level empty; set least-privilege per job

jobs:
  maintenance-agent:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    timeout-minutes: 20
    if: github.event_name == 'schedule' || (github.event.inputs.agent_type || '') == 'maintenance'
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: ðŸ Set up Python 3.12
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: pip

      - name: âš™ï¸ Install maintenance tools
        run: |
          python -m pip install --upgrade pip
          pip install black isort autoflake pyupgrade pre-commit

      - name: ðŸ§¹ Automated Code Maintenance
        run: |
          echo "ðŸ¤– Starting automated code maintenance..."
          changes_made=false
          if ! black --check --diff app/ 2>/dev/null; then
            echo "ðŸ”§ Auto-formatting code with Black..."; black app/; changes_made=true; fi
          if ! isort --check-only app/ 2>/dev/null; then
            echo "ðŸ”§ Sorting imports with isort..."; isort app/; changes_made=true; fi
          echo "ðŸ”§ Removing unused imports..."; find app/ -name "*.py" -exec autoflake --in-place --remove-all-unused-imports {} \;
          echo "ðŸ”§ Upgrading Python syntax..."; find app/ -name "*.py" -exec pyupgrade --py312-plus {} \;
          # Detect changes
          if git status --porcelain | grep -q .; then changes_made=true; fi
          echo "CHANGES_MADE=$changes_made" >> $GITHUB_ENV

      - name: ðŸ“Š Generate Maintenance Report
        run: |
          python << 'EOF'
          import os
          import subprocess
          from datetime import datetime
          
          # Get git statistics
          def get_git_stats():
              try:
                  result = subprocess.run(['git', 'diff', '--stat'], capture_output=True, text=True)
                  return result.stdout.strip() if result.returncode == 0 else "No changes"
              except:
                  return "Error getting stats"
          
          # Generate report
          report = f"""# ðŸ¤– Automated Maintenance Report
          
          **Date:** {datetime.now().strftime('%Y-%m-%d %H:%M UTC')}
          **Agent:** Code Maintenance Bot
          
          ## ðŸ“Š Changes Summary
          
          {get_git_stats()}
          
          ## ðŸ”§ Maintenance Tasks Completed
          
          - âœ… Code formatting (Black)
          - âœ… Import sorting (isort)  
          - âœ… Unused import removal (autoflake)
          - âœ… Python syntax upgrades (pyupgrade)
          
          ## ðŸ“ˆ Code Quality Metrics
          
          - **Formatting**: Consistent with Black standards
          - **Import Style**: PEP8 compliant with isort
          - **Python Version**: Upgraded to 3.12+ syntax
          - **Unused Code**: Cleaned automatically
          
          ---
          *This report was generated by the automated maintenance agent*
          """
          
          with open('maintenance_report.md', 'w') as f:
              f.write(report)
          
          print("âœ… Maintenance report generated")
          EOF

      - name: ðŸš€ Create Maintenance PR
        if: ${{ env.CHANGES_MADE == 'true' }}
        run: |
          # Configure git
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action - Code Maintenance Bot"
          
          # Create branch
          branch_name="automated-maintenance-$(date +%Y%m%d-%H%M%S)"
          git checkout -b "$branch_name"
          
          # Commit changes
          git add .
          git commit -m "ðŸ¤– Automated code maintenance
          
          - Auto-formatted code with Black
          - Sorted imports with isort
          - Removed unused imports
          - Upgraded Python syntax to 3.12+
          
          Generated by: Automated Code Maintenance Agent"
          
          # Push branch
          git push origin "$branch_name"
          
          # Store branch name for PR creation
          echo "MAINTENANCE_BRANCH=$branch_name" >> $GITHUB_ENV

      - name: ðŸ“ Create Maintenance Pull Request
        if: ${{ env.CHANGES_MADE == 'true' }}
        uses: actions/github-script@v7
        with:
          script: |
            const branchName = process.env.MAINTENANCE_BRANCH;
            const fs = require('fs');
            // Avoid duplicate PRs
            const existing = await github.rest.pulls.list({ owner: context.repo.owner, repo: context.repo.repo, state: 'open' });
            if (existing.data.some(pr => pr.title === 'ðŸ¤– Automated Code Maintenance')) {
              core.info('Existing maintenance PR found, skipping creation.');
              return;
            }
            
            let prBody = '## ðŸ¤– Automated Code Maintenance\n\n';
            prBody += 'This PR was automatically created by the Code Maintenance Agent.\n\n';
            prBody += '### ðŸ”§ Changes Made:\n';
            prBody += '- âœ… **Code Formatting**: Applied Black formatting standards\n';
            prBody += '- âœ… **Import Sorting**: Organized imports with isort\n';
            prBody += '- âœ… **Cleanup**: Removed unused imports and variables\n';
            prBody += '- âœ… **Syntax**: Upgraded to Python 3.12+ syntax\n\n';
            prBody += '### ðŸ“Š Impact:\n';
            prBody += '- Improved code consistency\n';
            prBody += '- Enhanced readability\n';
            prBody += '- Reduced technical debt\n';
            prBody += '- Better performance with modern syntax\n\n';
            prBody += '### âœ… Safe to Merge:\n';
            prBody += '- Only formatting and syntax changes\n';
            prBody += '- No functional logic modifications\n';
            prBody += '- All existing tests should continue to pass\n\n';
            
            if (fs.existsSync('maintenance_report.md')) {
              const report = fs.readFileSync('maintenance_report.md', 'utf8');
              prBody += '### ðŸ“‹ Detailed Report:\n';
              prBody += '```markdown\n' + report + '\n```\n';
            }
            
            prBody += '\n---\n';
            prBody += 'ðŸ¤– *Automatically generated by Code Maintenance Agent*';
            
            const { data: pr } = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'ðŸ¤– Automated Code Maintenance',
              head: branchName,
              base: 'main',
              body: prBody
            });
            
            // Add labels
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              labels: ['automated', 'maintenance', 'code-quality']
            });
            
            console.log(`âœ… Created maintenance PR #${pr.number}`);

  security-audit-agent:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read
    timeout-minutes: 30
    if: github.event.inputs.agent_type == 'security_audit'
    
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ðŸ Set up Python 3.12
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: pip

      - name: âš™ï¸ Install security tools
        run: |
          python -m pip install --upgrade pip
          pip install bandit safety semgrep

      - name: ðŸ”’ Comprehensive Security Audit
        run: |
          echo "ðŸ›¡ï¸ Starting comprehensive security audit..."
          
          # Bandit security scan
          echo "ðŸ” Running Bandit security scan..."
          bandit -r app/ -f json -o bandit_report.json || true
          
          # Safety dependency scan
          echo "ðŸ” Running Safety dependency scan..."
          safety check --json --output safety_report.json || true
          
          # Semgrep security patterns
          echo "ðŸ” Running Semgrep security analysis..."
          if command -v semgrep &> /dev/null; then
            semgrep --config=auto app/ --json --output semgrep_report.json || true
          fi
          
          echo "âœ… Security audit completed"

      - name: ðŸ“Š Generate Security Report
        run: |
          python << 'EOF'
          import json
          import os
          from datetime import datetime
          
          def load_json_report(filename):
              try:
                  with open(filename, 'r') as f:
                      return json.load(f)
              except:
                  return {}
          
          # Load security reports
          bandit_report = load_json_report('bandit_report.json')
          safety_report = load_json_report('safety_report.json')
          semgrep_report = load_json_report('semgrep_report.json')
          
          # Generate comprehensive report
          report = f"""# ðŸ›¡ï¸ Security Audit Report
          
          **Date:** {datetime.now().strftime('%Y-%m-%d %H:%M UTC')}
          **Agent:** Security Audit Bot
          
          ## ðŸ“Š Security Summary
          
          """
          
          # Bandit results
          bandit_issues = bandit_report.get('results', [])
          high_severity = len([i for i in bandit_issues if i.get('issue_severity') == 'HIGH'])
          medium_severity = len([i for i in bandit_issues if i.get('issue_severity') == 'MEDIUM'])
          low_severity = len([i for i in bandit_issues if i.get('issue_severity') == 'LOW'])
          
          report += f"""### ðŸ” Static Analysis (Bandit)
          - ðŸ”´ High Severity: {high_severity}
          - ðŸŸ¡ Medium Severity: {medium_severity}  
          - ðŸŸ¢ Low Severity: {low_severity}
          
          """
          
          # Safety results
          vulnerabilities = safety_report.get('vulnerabilities', []) if isinstance(safety_report, dict) else []
          report += f"""### ðŸ“¦ Dependency Vulnerabilities (Safety)
          - Total Vulnerabilities: {len(vulnerabilities)}
          
          """
          
          # Detailed findings
          if bandit_issues:
              report += "## ðŸ” Detailed Findings\n\n"
              for issue in bandit_issues[:10]:  # Top 10 issues
                  report += f"### {issue.get('test_name', 'Unknown')}\n"
                  report += f"**Severity:** {issue.get('issue_severity', 'Unknown')}\n"
                  report += f"**File:** {issue.get('filename', 'Unknown')}\n"
                  report += f"**Line:** {issue.get('line_number', 'Unknown')}\n"
                  report += f"**Issue:** {issue.get('issue_text', 'No description')}\n\n"
          
          # Recommendations
          report += """## ðŸŽ¯ Recommendations
          
          1. **Address High Severity Issues**: Priority should be given to high severity findings
          2. **Update Dependencies**: Keep all dependencies updated to latest secure versions
          3. **Code Review**: Manual review of flagged security patterns
          4. **Security Training**: Team education on secure coding practices
          
          ---
          *This report was generated by the automated security audit agent*
          """
          
          with open('security_audit_report.md', 'w') as f:
              f.write(report)
          
          print("âœ… Security audit report generated")
          EOF

      - name: ðŸš¨ Create Security Issue
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            let issueBody = '## ðŸ›¡ï¸ Automated Security Audit Results\n\n';
            issueBody += 'The automated security audit agent has completed its analysis.\n\n';
            
            if (fs.existsSync('security_audit_report.md')) {
              const report = fs.readFileSync('security_audit_report.md', 'utf8');
              issueBody += report;
            }
            
            issueBody += '\n\n### ðŸŽ¯ Action Items:\n';
            issueBody += '- [ ] Review high severity security findings\n';
            issueBody += '- [ ] Update vulnerable dependencies\n';
            issueBody += '- [ ] Implement recommended security controls\n';
            issueBody += '- [ ] Schedule follow-up security review\n';
            
            const { data: issue } = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ðŸ›¡ï¸ Security Audit Report - ${new Date().toISOString().split('T')[0]}`,
              body: issueBody,
              labels: ['security', 'audit', 'automated']
            });
            
            console.log(`âœ… Created security audit issue #${issue.number}`);

      - name: ðŸ“¤ Upload Security Reports
        uses: actions/upload-artifact@v4
        with:
          name: security-audit-reports
          path: |
            bandit_report.json
            safety_report.json
            semgrep_report.json
            security_audit_report.md
          retention-days: 90

  performance-optimization-agent:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    timeout-minutes: 25
    if: github.event.inputs.agent_type == 'performance_optimization'
    
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ðŸ Set up Python 3.12
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: pip

      - name: âš™ï¸ Install performance tools
        run: |
          python -m pip install --upgrade pip
          pip install line-profiler memory-profiler py-spy vulture pyinstrument

      - name: ðŸš€ Performance Analysis
        run: |
          echo "âš¡ Starting performance optimization analysis..."
          
          # Find unused code
          echo "ðŸ” Detecting unused code..."
          vulture app/ --min-confidence 70 > unused_code_report.txt 2>&1 || true
          
          # Memory usage patterns
          echo "ðŸ’¾ Analyzing memory usage patterns..."
          python << 'EOF'
          import ast
          import os
          from pathlib import Path
          
          def analyze_memory_patterns(file_path):
              """Analyze potential memory issues"""
              issues = []
              try:
                  with open(file_path, 'r') as f:
                      content = f.read()
                      tree = ast.parse(content)
                  
                  # Look for potential memory issues
                  for node in ast.walk(tree):
                      if isinstance(node, ast.ListComp):
                          if len(ast.dump(node)) > 200:  # Large list comprehension
                              issues.append(f"Line {node.lineno}: Large list comprehension - consider generator")
                      
                      elif isinstance(node, ast.For):
                          # Look for list appends in loops
                          for child in ast.walk(node):
                              if isinstance(child, ast.Call) and hasattr(child.func, 'attr'):
                                  if child.func.attr == 'append':
                                      issues.append(f"Line {node.lineno}: List append in loop - consider list comprehension")
                  
                  return issues
              except:
                  return []
          
          # Analyze all Python files
          all_issues = []
          for py_file in Path('app').rglob('*.py'):
              if py_file.is_file():
                  issues = analyze_memory_patterns(py_file)
                  if issues:
                      all_issues.extend([(str(py_file), issue) for issue in issues])
          
          # Save results
          with open('memory_analysis.txt', 'w') as f:
              f.write("Memory Usage Analysis Results\n")
              f.write("=" * 40 + "\n\n")
              
              if all_issues:
                  for file_path, issue in all_issues:
                      f.write(f"{file_path}: {issue}\n")
              else:
                  f.write("No significant memory issues detected.\n")
          
          print("âœ… Memory analysis completed")
          EOF

      - name: ðŸ“Š Generate Performance Report
        run: |
          python << 'EOF'
          import os
          from datetime import datetime
          
          # Read analysis results
          unused_code = ""
          if os.path.exists('unused_code_report.txt'):
              with open('unused_code_report.txt', 'r') as f:
                  unused_code = f.read()
          
          memory_analysis = ""
          if os.path.exists('memory_analysis.txt'):
              with open('memory_analysis.txt', 'r') as f:
                  memory_analysis = f.read()
          
          # Generate report
          report = f"""# âš¡ Performance Optimization Report
          
          **Date:** {datetime.now().strftime('%Y-%m-%d %H:%M UTC')}
          **Agent:** Performance Optimization Bot
          
          ## ðŸŽ¯ Performance Analysis Summary
          
          ### ðŸ§¹ Unused Code Detection
          ```
          {unused_code[:1000]}...
          ```
          
          ### ðŸ’¾ Memory Usage Analysis
          ```
          {memory_analysis}
          ```
          
          ## ðŸš€ Optimization Recommendations
          
          ### 1. Code Optimization
          - Remove unused imports and functions
          - Use generators instead of lists where possible
          - Implement caching for expensive operations
          - Optimize database queries with proper indexing
          
          ### 2. Memory Optimization  
          - Use `__slots__` for classes with many instances
          - Implement object pooling for frequently created objects
          - Use numpy arrays for numerical computations
          - Profile memory usage in production
          
          ### 3. Algorithm Optimization
          - Profile critical paths with line_profiler
          - Consider algorithmic complexity improvements
          - Implement parallel processing where applicable
          - Use appropriate data structures
          
          ### 4. I/O Optimization
          - Implement connection pooling
          - Use async/await for I/O bound operations
          - Batch database operations
          - Cache frequently accessed data
          
          ---
          *This report was generated by the automated performance optimization agent*
          """
          
          with open('performance_optimization_report.md', 'w') as f:
              f.write(report)
          
          print("âœ… Performance optimization report generated")
          EOF

      - name: ðŸ“¤ Upload Performance Reports
        uses: actions/upload-artifact@v4
        with:
          name: performance-optimization-reports
          path: |
            unused_code_report.txt
            memory_analysis.txt
            performance_optimization_report.md
          retention-days: 60

  dependency-update-agent:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
    timeout-minutes: 20
    if: github.event.inputs.agent_type == 'dependency_update'
    
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ðŸ Set up Python 3.12
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: pip

      - name: ðŸ“¦ Analyze Dependencies
        run: |
          echo "ðŸ“¦ Analyzing dependency updates..."
          python -m pip install --upgrade pip pip-tools
          if [ -f requirements.in ]; then
            pip-compile --upgrade --generate-hashes requirements.in || pip-compile --upgrade requirements.in || echo "Could not compile requirements";
          fi
          pip list --outdated --format=json > outdated_packages.json 2>/dev/null || echo "[]" > outdated_packages.json

      - name: ðŸ“Š Generate Dependency Report
        run: |
          python << 'EOF'
          import json
          import subprocess
          from datetime import datetime
          
          # Load outdated packages
          try:
              with open('outdated_packages.json', 'r') as f:
                  outdated = json.load(f)
          except:
              outdated = []
          
          # Generate report
          report = f"""# ðŸ“¦ Dependency Update Report
          
          **Date:** {datetime.now().strftime('%Y-%m-%d %H:%M UTC')}
          **Agent:** Dependency Update Bot
          
          ## ðŸ“Š Update Summary
          
          **Total Outdated Packages:** {len(outdated)}
          
          """
          
          if outdated:
              report += "### ðŸ“‹ Outdated Packages\n\n"
              report += "| Package | Current | Latest | Type |\n"
              report += "|---------|---------|--------|----- |\n"
              
              for pkg in outdated:
                  name = pkg.get('name', 'Unknown')
                  current = pkg.get('version', 'Unknown')
                  latest = pkg.get('latest_version', 'Unknown')
                  pkg_type = 'Security' if 'security' in name.lower() else 'Feature'
                  report += f"| {name} | {current} | {latest} | {pkg_type} |\n"
              
              report += "\n"
          
          report += """## ðŸŽ¯ Update Recommendations
          
          ### ðŸ”’ Security Updates (High Priority)
          - Security-related packages should be updated immediately
          - Test thoroughly before deployment
          
          ### ðŸš€ Feature Updates (Medium Priority)  
          - Review changelog for breaking changes
          - Update gradually and monitor for issues
          
          ### ðŸ§ª Development Dependencies (Low Priority)
          - Can be updated more frequently
          - Focus on tools that improve developer experience
          
          ---
          *This report was generated by the automated dependency update agent*
          """
          
          with open('dependency_update_report.md', 'w') as f:
              f.write(report)
          
          print("âœ… Dependency update report generated")
          EOF

      - name: ðŸ“¤ Upload Dependency Reports
        uses: actions/upload-artifact@v4
        with:
          name: dependency-update-reports
          path: |
            outdated_packages.json
            dependency_update_report.md
          retention-days: 30
