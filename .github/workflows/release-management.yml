name: üì¶ Release Management

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Version bump type'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major
      pre_release:
        description: 'Is this a pre-release?'
        required: false
        default: false
        type: boolean

env:
  DOCKER_REGISTRY: ghcr.io
  IMAGE_NAME: routeforce

permissions:
  contents: write
  packages: write
  pull-requests: write

jobs:
  # Create version and release
  create-release:
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'
    outputs:
      new_version: ${{ steps.version.outputs.new_version }}
      changelog: ${{ steps.changelog.outputs.changelog }}
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: üè∑Ô∏è Generate new version
        id: version
        run: |
          # Get the latest tag
          latest_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Latest tag: $latest_tag"
          
          # Remove 'v' prefix and split version
          version=${latest_tag#v}
          IFS='.' read -r major minor patch <<< "$version"
          
          # Bump version based on input
          case "${{ github.event.inputs.version_type }}" in
            "major")
              major=$((major + 1))
              minor=0
              patch=0
              ;;
            "minor")
              minor=$((minor + 1))
              patch=0
              ;;
            "patch")
              patch=$((patch + 1))
              ;;
          esac
          
          new_version="v$major.$minor.$patch"
          
          # Add pre-release suffix if specified
          if [ "${{ github.event.inputs.pre_release }}" = "true" ]; then
            timestamp=$(date +%Y%m%d%H%M%S)
            new_version="$new_version-pre.$timestamp"
          fi
          
          echo "New version: $new_version"
          echo "new_version=$new_version" >> $GITHUB_OUTPUT

      - name: üìù Generate changelog
        id: changelog
        run: |
          echo "Generating changelog since $latest_tag..."
          
          # Generate changelog from git commits
          changelog=$(git log $latest_tag..HEAD --pretty=format:"- %s (%h)" --no-merges | head -50)
          
          if [ -z "$changelog" ]; then
            changelog="- No significant changes"
          fi
          
          echo "Generated changelog:"
          echo "$changelog"
          
          # Save changelog to output (properly escaped)
          {
            echo "changelog<<EOF"
            echo "$changelog"
            echo "EOF"
          } >> $GITHUB_OUTPUT

      - name: üè∑Ô∏è Create and push tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          
          git tag -a ${{ steps.version.outputs.new_version }} -m "Release ${{ steps.version.outputs.new_version }}"
          git push origin ${{ steps.version.outputs.new_version }}

  # Build and publish release
  build-and-release:
    runs-on: ubuntu-latest
    needs: create-release
    if: always() && (github.event_name == 'push' || needs.create-release.result == 'success')
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üêç Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'

      - name: üîê Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: üè∑Ô∏è Extract version
        id: version
        run: |
          if [ "${{ github.event_name }}" = "push" ]; then
            version=${GITHUB_REF#refs/tags/}
          else
            version="${{ needs.create-release.outputs.new_version }}"
          fi
          echo "version=$version" >> $GITHUB_OUTPUT
          echo "Version: $version"

      - name: üê≥ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üèóÔ∏è Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ env.DOCKER_REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.version }}
            ${{ env.DOCKER_REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:latest
          labels: |
            org.opencontainers.image.title=RouteForce
            org.opencontainers.image.description=Advanced route optimization platform
            org.opencontainers.image.version=${{ steps.version.outputs.version }}
            org.opencontainers.image.source=https://github.com/${{ github.repository }}
            org.opencontainers.image.created=${{ github.event.repository.updated_at }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: üì¶ Build Python package
        run: |
          python -m pip install --upgrade pip build
          python -m build --sdist --wheel

      - name: üìù Generate release notes
        id: release_notes
        run: |
          version="${{ steps.version.outputs.version }}"
          
          # Get changelog from create-release job or generate from git
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            changelog="${{ needs.create-release.outputs.changelog }}"
          else
            # For tag pushes, generate changelog from recent commits
            previous_tag=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
            if [ -n "$previous_tag" ]; then
              changelog=$(git log $previous_tag..HEAD --pretty=format:"- %s (%h)" --no-merges | head -20)
            else
              changelog="- Initial release"
            fi
          fi
          
          # Create release notes
          cat > release_notes.md <<EOF
          # üöÄ RouteForce $version
          
          ## üìã What's Changed
          $changelog
          
          ## üê≥ Docker Image
          \`\`\`bash
          docker pull ${{ env.DOCKER_REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:$version
          \`\`\`
          
          ## üì¶ Installation
          \`\`\`bash
          pip install routeforce==$version
          \`\`\`
          
          ## üîß Deployment
          This release includes:
          - ‚úÖ Production-ready Docker image
          - ‚úÖ Comprehensive test coverage
          - ‚úÖ Security scanning passed
          - ‚úÖ Performance benchmarks validated
          
          **Full Changelog**: https://github.com/${{ github.repository }}/compare/$previous_tag...$version
          EOF
          
          echo "Generated release notes:"
          cat release_notes.md

      - name: üéâ Create GitHub Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.version.outputs.version }}
          release_name: üöÄ RouteForce ${{ steps.version.outputs.version }}
          body_path: release_notes.md
          draft: false
          prerelease: ${{ contains(steps.version.outputs.version, 'pre') || github.event.inputs.pre_release == 'true' }}

      - name: üì§ Upload release assets
        if: always()
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: dist/
          asset_name: python-packages
          asset_content_type: application/zip

  # Notify about release
  notify-release:
    runs-on: ubuntu-latest
    needs: [create-release, build-and-release]
    if: always() && (needs.build-and-release.result == 'success')
    
    steps:
      - name: üì¢ Notify team
        run: |
          version="${{ needs.create-release.outputs.new_version || github.ref_name }}"
          echo "üéâ RouteForce $version has been released!"
          echo "Docker image: ${{ env.DOCKER_REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:$version"
          
          # Here you could add notifications to Slack, Discord, etc.
          # Example:
          # curl -X POST -H 'Content-type: application/json' \
          #   --data '{"text":"üöÄ RouteForce '$version' released!"}' \
          #   ${{ secrets.SLACK_WEBHOOK_URL }}

  # Deploy to staging after release
  deploy-staging:
    runs-on: ubuntu-latest
    needs: [build-and-release]
    if: always() && needs.build-and-release.result == 'success' && !contains(github.ref_name, 'pre')
    environment: staging
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üöÄ Deploy to staging
        run: |
          echo "üöÄ Deploying to staging environment..."
          version="${{ github.ref_name || needs.create-release.outputs.new_version }}"
          
          # Here you would add your actual deployment logic
          # For example, updating a Kubernetes deployment, calling a webhook, etc.
          
          echo "‚úÖ Deployed RouteForce $version to staging"
          echo "Staging URL: https://staging.routeforce.app"
          
          # Example deployment commands:
          # kubectl set image deployment/routeforce routeforce=${{ env.DOCKER_REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:$version
          # kubectl rollout status deployment/routeforce

      - name: üß™ Smoke tests
        run: |
          echo "Running smoke tests against staging..."
          
          # Add your smoke tests here
          # curl -f https://staging.routeforce.app/health || exit 1
          # curl -f https://staging.routeforce.app/api/v1/status || exit 1
          
          echo "‚úÖ Smoke tests passed"
