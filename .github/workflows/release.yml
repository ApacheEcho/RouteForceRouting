name: Release Automation

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., v1.0.0)'
        required: true
        type: string

permissions:
  contents: write
  packages: write
  pull-requests: write

env:
  PYTHON_VERSION: "3.12"

jobs:
  prepare-release:
    name: Prepare Release
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
      is_prerelease: ${{ steps.version.outputs.is_prerelease }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine version
        id: version
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION="${{ github.ref_name }}"
          fi
          
          # Remove 'v' prefix if present
          VERSION_NUMBER=${VERSION#v}
          
          echo "version=${VERSION_NUMBER}" >> $GITHUB_OUTPUT
          echo "tag=${VERSION}" >> $GITHUB_OUTPUT
          
          # Check if this is a prerelease (contains alpha, beta, rc, etc.)
          if [[ "${VERSION_NUMBER}" =~ (alpha|beta|rc|pre) ]]; then
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
          else
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
          fi
          
          echo "Release version: ${VERSION_NUMBER}"
          echo "Release tag: ${VERSION}"

  test:
    name: Run Tests
    runs-on: ubuntu-latest
    needs: prepare-release

    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: routeforce_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Cache pip dependencies
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov black flake8

      - name: Run code quality checks
        run: |
          # Code formatting check
          black --check --diff . || echo "âš ï¸ Code formatting issues found"
          
          # Linting
          flake8 app/ --count --select=E9,F63,F7,F82 --show-source --statistics || echo "âš ï¸ Critical linting issues found"

      - name: Run tests
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/routeforce_test
          REDIS_URL: redis://localhost:6379/0
          FLASK_ENV: testing
          SECRET_KEY: test-secret-key
          JWT_SECRET_KEY: test-jwt-secret
        run: |
          # Test app factory
          python -c "from app import create_app; app = create_app('testing'); print('âœ… App factory working')"
          
          # Run existing tests if any
          if find . -name "test_*.py" -o -name "*_test.py" | grep -q .; then
            pytest -v --tb=short
          else
            echo "âœ… No specific test files found, but app imports successfully"
          fi

  build:
    name: Build Release Assets
    runs-on: ubuntu-latest
    needs: [prepare-release, test]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install build

      - name: Update version in files
        run: |
          VERSION="${{ needs.prepare-release.outputs.version }}"
          echo "${VERSION}" > VERSION
          
          # Update version in app/__init__.py if __version__ exists
          if grep -q "__version__" app/__init__.py 2>/dev/null; then
            sed -i "s/__version__ = .*/__version__ = \"${VERSION}\"/" app/__init__.py
          fi

      - name: Create source distribution
        run: |
          # Create a simple setup.py for distribution if it doesn't exist
          if [ ! -f setup.py ]; then
            cat > setup.py << 'EOF'
          from setuptools import setup, find_packages
          
          with open("README.md", "r", encoding="utf-8") as fh:
              long_description = fh.read()
          
          with open("VERSION", "r", encoding="utf-8") as fh:
              version = fh.read().strip()
          
          setup(
              name="routeforce-routing",
              version=version,
              author="ApacheEcho",
              description="A route optimization engine for field execution teams",
              long_description=long_description,
              long_description_content_type="text/markdown",
              url="https://github.com/ApacheEcho/RouteForceRouting",
              packages=find_packages(),
              classifiers=[
                  "Development Status :: 3 - Alpha",
                  "Intended Audience :: Developers",
                  "License :: OSI Approved :: MIT License",
                  "Operating System :: OS Independent",
                  "Programming Language :: Python :: 3",
                  "Programming Language :: Python :: 3.11",
                  "Programming Language :: Python :: 3.12",
              ],
              python_requires=">=3.11",
              install_requires=[
                  line.strip()
                  for line in open("requirements.txt").readlines()
                  if line.strip() and not line.startswith("#")
              ],
              entry_points={
                  "console_scripts": [
                      "routeforce=app:create_app",
                  ],
              },
          )
          EOF
          fi
          
          # Build source distribution
          python setup.py sdist

      - name: Create deployment package
        run: |
          # Create deployment package with all necessary files
          mkdir -p dist/deployment
          
          # Copy application files
          cp -r app dist/deployment/
          cp -r static dist/deployment/ 2>/dev/null || true
          cp -r templates dist/deployment/ 2>/dev/null || true
          cp -r frontend dist/deployment/ 2>/dev/null || true
          
          # Copy configuration files
          cp requirements.txt dist/deployment/
          cp app.py dist/deployment/ 2>/dev/null || true
          cp main.py dist/deployment/ 2>/dev/null || true
          cp wsgi.py dist/deployment/ 2>/dev/null || true
          cp Procfile dist/deployment/ 2>/dev/null || true
          cp runtime.txt dist/deployment/ 2>/dev/null || true
          cp VERSION dist/deployment/
          cp README.md dist/deployment/
          cp CHANGELOG.md dist/deployment/
          
          # Copy Docker files
          cp Dockerfile* dist/deployment/ 2>/dev/null || true
          cp docker-compose*.yml dist/deployment/ 2>/dev/null || true
          
          # Copy deployment scripts
          cp deploy*.sh dist/deployment/ 2>/dev/null || true
          
          # Create tarball
          cd dist
          tar -czf routeforce-v${{ needs.prepare-release.outputs.version }}.tar.gz deployment/

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-assets
          path: |
            dist/*.tar.gz
            dist/*.whl

  generate-changelog:
    name: Generate Changelog
    runs-on: ubuntu-latest
    needs: [prepare-release, test]
    outputs:
      release_notes: ${{ steps.changelog.outputs.release_notes }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate release notes
        id: changelog
        run: |
          VERSION="${{ needs.prepare-release.outputs.version }}"
          TAG="${{ needs.prepare-release.outputs.tag }}"
          
          # Get the previous tag
          PREVIOUS_TAG=$(git tag --sort=-version:refname | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+' | head -2 | tail -1)
          
          if [ -z "$PREVIOUS_TAG" ]; then
            # First release - get all commits
            COMMITS=$(git log --oneline --pretty=format:"- %s (%h)" HEAD)
            echo "## What's New in ${TAG}" > release_notes.md
            echo "" >> release_notes.md
            echo "This is the initial release of RouteForce Routing." >> release_notes.md
            echo "" >> release_notes.md
            echo "### Features" >> release_notes.md
            echo "- Route optimization engine for field execution teams" >> release_notes.md
            echo "- Google Maps integration for route visualization" >> release_notes.md
            echo "- Geocoding cache for performance optimization" >> release_notes.md
            echo "- Flask web application with modern architecture" >> release_notes.md
            echo "- Analytics and monitoring capabilities" >> release_notes.md
            echo "- Enterprise features for multi-user support" >> release_notes.md
            echo "- Real-time WebSocket features" >> release_notes.md
            echo "- Comprehensive testing and CI/CD pipeline" >> release_notes.md
          else
            # Generate changelog from commits since last tag
            echo "## What's New in ${TAG}" > release_notes.md
            echo "" >> release_notes.md
            
            # Get commits since last release
            COMMITS=$(git log ${PREVIOUS_TAG}..HEAD --oneline --pretty=format:"- %s (%h)")
            
            if [ -n "$COMMITS" ]; then
              echo "### Changes" >> release_notes.md
              echo "$COMMITS" >> release_notes.md
            else
              echo "### Changes" >> release_notes.md
              echo "- Maintenance release with minor improvements" >> release_notes.md
            fi
          fi
          
          echo "" >> release_notes.md
          echo "### Installation" >> release_notes.md
          echo "" >> release_notes.md
          echo "\`\`\`bash" >> release_notes.md
          echo "# Download and extract" >> release_notes.md
          echo "wget https://github.com/ApacheEcho/RouteForceRouting/releases/download/${TAG}/routeforce-${VERSION}.tar.gz" >> release_notes.md
          echo "tar -xzf routeforce-${VERSION}.tar.gz" >> release_notes.md
          echo "cd deployment" >> release_notes.md
          echo "" >> release_notes.md
          echo "# Install dependencies" >> release_notes.md
          echo "pip install -r requirements.txt" >> release_notes.md
          echo "" >> release_notes.md
          echo "# Run the application" >> release_notes.md
          echo "python app.py" >> release_notes.md
          echo "\`\`\`" >> release_notes.md
          echo "" >> release_notes.md
          echo "**Full Changelog**: https://github.com/ApacheEcho/RouteForceRouting/compare/${PREVIOUS_TAG}...${TAG}" >> release_notes.md
          
          # Update CHANGELOG.md
          if [ -f CHANGELOG.md ]; then
            # Create temporary file with new entry
            echo "# Changelog" > CHANGELOG_new.md
            echo "" >> CHANGELOG_new.md
            echo "All notable changes to the RouteForce Routing project will be documented in this file." >> CHANGELOG_new.md
            echo "" >> CHANGELOG_new.md
            echo "The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/)," >> CHANGELOG_new.md
            echo "and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html)." >> CHANGELOG_new.md
            echo "" >> CHANGELOG_new.md
            echo "## [Unreleased]" >> CHANGELOG_new.md
            echo "" >> CHANGELOG_new.md
            echo "## [${VERSION}] - $(date +%Y-%m-%d)" >> CHANGELOG_new.md
            echo "" >> CHANGELOG_new.md
            
            # Add the release notes content (skip the title)
            tail -n +3 release_notes.md >> CHANGELOG_new.md
            echo "" >> CHANGELOG_new.md
            
            # Append the rest of the existing changelog (skip the header and unreleased section)
            sed -n '/^## \[.*\] - [0-9]/,$p' CHANGELOG.md >> CHANGELOG_new.md
            
            mv CHANGELOG_new.md CHANGELOG.md
          fi
          
          # Set output for GitHub release
          {
            echo 'release_notes<<EOF'
            cat release_notes.md
            echo 'EOF'
          } >> $GITHUB_OUTPUT

  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [prepare-release, test, build, generate-changelog]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: release-assets
          path: dist/

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.prepare-release.outputs.tag }}
          name: Release ${{ needs.prepare-release.outputs.tag }}
          body: ${{ needs.generate-changelog.outputs.release_notes }}
          draft: false
          prerelease: ${{ needs.prepare-release.outputs.is_prerelease }}
          files: |
            dist/*.tar.gz
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Update CHANGELOG.md
        run: |
          # The changelog was already updated in generate-changelog job
          # Just commit it back to the repository
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          if git diff --quiet; then
            echo "No changes to commit"
          else
            git add CHANGELOG.md
            git commit -m "Update CHANGELOG.md for release ${{ needs.prepare-release.outputs.tag }}"
            git push
          fi

  post-release:
    name: Post-Release Actions
    runs-on: ubuntu-latest
    needs: [prepare-release, create-release]
    if: always() && needs.create-release.result == 'success'

    steps:
      - name: Notify success
        run: |
          echo "âœ… Release ${{ needs.prepare-release.outputs.tag }} created successfully!"
          echo "ðŸ”— Release URL: https://github.com/ApacheEcho/RouteForceRouting/releases/tag/${{ needs.prepare-release.outputs.tag }}"

      - name: Trigger deployment
        if: needs.prepare-release.outputs.is_prerelease == 'false'
        run: |
          echo "ðŸš€ Triggering production deployment for stable release"
          # This could trigger the existing deploy workflow or other deployment processes